#include "ast.h"
#include "base.h"

#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include "lex.h"

#define SYMS_SCOPE_INIT 16 

enum SymbolType {
    SYM_VAR,
    SYM_FUNC,
    SYM_ALL,
};

struct Symbol {
    char* name;
    char* type;
    enum SymbolType sym_type;
};

static struct Token*    parserpeek(struct Parser* parser);
static struct Token*    parserprev(struct Parser* parser);
static uint8_t          parseratend(struct Parser* parser);
static struct Token*    parseradvance(struct Parser* parser);
static uint8_t          parserhave(struct Parser* parser, enum TokenType type);
static struct Token*    parserconsume(struct Parser* parser, enum TokenType type);
static uint8_t          parsermatch(struct Parser* parser, enum TokenType type);

static struct AstNode*  astemitnode(enum AstNodeType type);
static struct AstNode*  astemitfuncnode(char* name, char* type, struct AstNode* body);
static struct AstNode*  astemitvarnode(char* name, char* type, struct AstNode* val);
static struct AstNode*  astemitnumbernode(int64_t number);
static struct AstNode*  astemitidentnode(char* ident);
static int8_t           astaddchild(struct AstNode* parent, struct AstNode* child);
struct AstNode*         astfinishcall(struct Parser* parser, char* name);

struct AstNode* parserparsefactor(struct Parser* parser);
struct AstNode* parserparseterm(struct Parser* parser);
struct AstNode* parserparseexpr(struct Parser* parser);

struct AstNode* parserfinishcall(struct Parser* parser, char* name);
struct AstNode* parserparseident(struct Parser* parser);
struct AstNode* parserparsestmt(struct Parser* parser);
struct AstNode* parserparseblock(struct Parser* parser);
struct AstNode* parserparsefunc(struct Parser* parser);

static struct Token* parserpeek(struct Parser* parser) {
  return &parser->toks[parser->cur];
}

struct Token* parserprev(struct Parser* parser) {
  return &parser->toks[parser->cur - 1];
}

uint8_t parseratend(struct Parser* parser) {
  return parser->cur >= parser->toks_n; 
}

struct Token* parseradvance(struct Parser* parser) {
  if(!parseratend(parser)) parser->cur++; 
  return parserprev(parser);
}

uint8_t parserhave(struct Parser* parser, enum TokenType type) {
  if(parseratend(parser)) return 0;
  return parserpeek(parser)->type == type;
}

struct Token* parserconsume(struct Parser* parser, enum TokenType type) {
  if(parserhave(parser, type)) return parseradvance(parser);

  fprintf(stderr, "ivar: expected token '%s' (got '%s').\n", lextktostr(type), lextktostr(
    parserpeek(parser)->type
  ));
  exit(1);

  return NULL;
}

uint8_t parsermatch(struct Parser* parser, enum TokenType type) {
  if(parserhave(parser, type)) {
    parseradvance(parser);
    return 1;
  }
  return 0;
}

struct AstNode* astemitnode(enum AstNodeType type) {
  struct AstNode* node = _malloc(sizeof(*node));
  assert(node);

  memset(node, 0, sizeof(*node));

  node->type = type;

  return node;
}

struct AstNode* astemitfuncnode(char* name, char* type, struct AstNode* body) {
  struct AstNode* n = astemitnode(AST_FUNCTION);
  if(!n) return NULL;

  n->function.name = name; 
  n->function.type = type;
  n->function.body = body;
  return n;
}
struct AstNode* astemitvarnode(char* name, char* type, struct AstNode* val) {
  struct AstNode* n = astemitnode(AST_VAR_DECL);
  if(!n) return NULL;

  n->var_decl.name = name; 
  n->var_decl.type = type;
  n->var_decl.val = val;
  return n;
}

struct AstNode* astemitnumbernode(int64_t number) {
  struct AstNode* n = astemitnode(AST_NUMBER);
  if(!n) return NULL;

  n->number = number; 
  return n;
}

struct AstNode* astemitidentnode(char* ident) {
  struct AstNode* n = astemitnode(AST_IDENT);
  if(!n) return NULL;

  n->ident = ident; 
  return n;
}

struct AstNode* astemitbinopnode(struct AstNode* left, enum TokenType op, struct AstNode* right) {
  struct AstNode* n = astemitnode(AST_BINOP);
  if(!n) return NULL;

  n->binop.left = left;
  n->binop.op = op;
  n->binop.right = right;

  return n;
}

int8_t astaddchild(struct AstNode* parent, struct AstNode* child) {
  if(!parent || !child) return 1;

  if(parent->list.childs_n >= parent->list.childs_cap) {
    uint32_t new_cap = parent->list.childs_cap == 0 ? 2 : parent->list.childs_cap * 2;
    parent->list.childs = _realloc(parent->list.childs, sizeof(*parent->list.childs) * new_cap);
    assert(parent->list.childs);
    parent->list.childs_cap = new_cap;
  }
  parent->list.childs[parent->list.childs_n++] = child;

  return 0;
}

struct AstNode* parserparsefactor(struct Parser* parser) {
  struct Token* tk = parserpeek(parser);
  if(tk->type == TK_NUMBER) {
    parserconsume(parser, TK_NUMBER);
    return astemitnumbernode(tk->i_val);
  }
  else if(tk->type == TK_LPAREN) {
    parserconsume(parser, TK_LPAREN); 
    struct AstNode* expr = parserparseexpr(parser); 
    parserconsume(parser, TK_RPAREN); 
    return expr;
  }

  fprintf(stderr, "ivar: unexpected token: '%s', expected number or '('", lextktostr(tk->type));

  return NULL;
}

struct AstNode* parserparseterm(struct Parser* parser) {
  if(!parser) return NULL;

  struct AstNode* term = parserparsefactor(parser);

  while(parserhave(parser, TK_MUL) || parserhave(parser, TK_DIV)) {
    struct Token* tk = parserpeek(parser);
    if(tk->type == TK_MUL) parserconsume(parser, TK_MUL); 
    else if (tk->type == TK_DIV) parserconsume(parser, TK_DIV);

    term = astemitbinopnode(term, tk->type, parserparsefactor(parser)); 
  }

  return term;
}

struct AstNode* parserparseexpr(struct Parser* parser) {
  if(!parser) return NULL;

  struct AstNode* expr = parserparseterm(parser);
  
  return NULL;
}

struct AstNode* parserfinishcall(struct Parser* parser, char* name) {
  if(!parser || !name) return NULL;

  struct AstNode* call = astemitnode(AST_CALL);
  call->call.name = name; 
  while(!parserhave(parser, TK_RPAREN)) {
    struct AstNode* expr = parserparseexpr(parser);
    if(astaddchild(call, expr) != 0) {
      fprintf(stderr, "ivar: cannot add expression to call.\n");
      exit(1);
    }
    if(parserpeek(parser)->type != TK_RPAREN) {
      parserconsume(parser, TK_COMMA);
    }
  }
  parserconsume(parser, TK_RPAREN);
  return call; 
}

struct AstNode* parserparseident(struct Parser* parser) {
  if(!parser) return NULL;

  struct Token* name = parserconsume(parser, TK_IDENT);

  if(parsermatch(parser, TK_COLON)) {
    struct Token* type = parserconsume(parser, TK_IDENT);
    parserconsume(parser, TK_ASSIGN);
    struct AstNode* val = parserparseexpr(parser); 
    parserconsume(parser, TK_SEMI);
    return astemitvarnode(name->str_val, type->str_val, val);
  }

  if(parsermatch(parser, TK_LPAREN)) {
    struct AstNode* call = parserfinishcall(parser, name->str_val);
    parserconsume(parser, TK_SEMI);
    return call;
  } 

  fprintf(stderr, "ivar: unexpected token after identifier.\n");
  exit(1);
}

struct AstNode* parserparsestmt(struct Parser* parser) {
  if(!parser) return NULL;

  if(parserhave(parser, TK_IDENT)) {
    return parserparseident(parser);
  }
  if(parserhave(parser, TK_LCBRACE)) {
    return parserparseblock(parser);
  } 

  fprintf(stderr, "ivar: unexpected token.\n");
  exit(1);
  return NULL;
}

struct AstNode* parserparseblock(struct Parser* parser) {
  if(!parser) return NULL;

  parserconsume(parser, TK_LCBRACE);

  struct AstNode* block = astemitnode(AST_BLOCK);
  while(!parserhave(parser, TK_RCBRACE)) {
    struct AstNode* stmt = parserparsestmt(parser);
    if(astaddchild(block, stmt) != 0) {
      fprintf(stderr, "ivar: failed to add statement to block.\n");
      exit(1);
    }
  }

  parserconsume(parser, TK_RCBRACE);

  return block;
}

struct AstNode* parserparsefunc(struct Parser* parser) {
  if(!parser) return NULL;

  struct Token* name = parserconsume(parser, TK_IDENT);
  parserconsume(parser, TK_LPAREN);
  parserconsume(parser, TK_RPAREN);
  parserconsume(parser, TK_COLON);

  struct Token* type = parserconsume(parser, TK_IDENT);

  struct AstNode* body = parserparseblock(parser);

  return astemitfuncnode(name->str_val, type->str_val, body);
} 


int8_t parserinit(struct Parser* parser, struct Token* toks, size_t toks_n) {
  if(!parser || !toks) return 1;

  memset(parser, 0, sizeof(*parser));
  parser->toks = toks;
  parser->toks_n = toks_n;

  return 0;
}

struct AstNode* parserbuildast(struct Parser* parser) {
  if(!parser) return NULL;

  struct AstNode* program = astemitnode(AST_PROGRAM);

  while(!parseratend(parser)) {
    struct AstNode* func= parserparsefunc(parser);
    if(astaddchild(program, func) != 0) {
      fprintf(stderr, "ivar: failed to add function to program.\n");
      exit(1);
    }
  }

  return program;
}

struct Symbol* scopeaddsymbol(
  char* name, char* type, 
  enum SymbolType sym_type, struct Scope* scope) {
  if(scope->syms_n >= scope->syms_cap) {
    scope->syms_cap *= 2;
    scope->syms = _realloc(
      scope->syms, 
      sizeof(*scope->syms) * scope->syms_cap);
  }

  scope->syms[scope->syms_n] = (struct Symbol){
    .name = name, .type = type,
    .sym_type = sym_type,
  };

  return &scope->syms[scope->syms_n++];
}

struct Symbol* scopelookup(
  const char* name, enum SymbolType sym_type, 
  struct Scope* scope, uint8_t onlycurrent) {
  for(size_t i = 0; i < scope->syms_n; i++) {
    if(
      strcmp(scope->syms[i].name, name) == 0 && 
      (scope->syms[i].sym_type == sym_type || sym_type == SYM_ALL)
       ) {
      return &scope->syms[i];
    }
  }
  return (scope->parent && !onlycurrent ? 
  scopelookup(name, sym_type, scope->parent, 0) : NULL);
}

struct Scope* newscope(struct AstNode* node, struct Scope* parent) {
  if(!parent || !node) return NULL;

  struct Scope* newscope = _malloc(sizeof(*newscope));
  assert(newscope);
  memset(newscope, 0, sizeof(*newscope));

  newscope->syms_cap = SYMS_SCOPE_INIT;
  newscope->syms = _malloc(sizeof(*newscope->syms) * newscope->syms_cap);
  assert(newscope->syms);

  newscope->parent = parent;

  return newscope;
}

uint8_t semanticanalyze(struct AstNode* node, struct Scope* scope) {
  if(node->type == AST_BLOCK || node->type == AST_PROGRAM) {
    struct Scope* nextscope = newscope(node, scope); 
    if(!nextscope) return 1;

    for(size_t i = 0; i < node->list.childs_n; i++ ){
      semanticanalyze(node->list.childs[i], nextscope); 
    }
    free(nextscope);
  }

  else if(node->type == AST_VAR_DECL) {
    if(scopelookup(node->var_decl.name, SYM_VAR, scope, 1) != NULL) {
      fprintf(stderr, "ivar: '%s': redefinition.\n", node->var_decl.name);
      exit(1);
    }

    scopeaddsymbol(node->var_decl.name, node->var_decl.type, 
                   SYM_VAR, scope);
  } 
  else if(node->type == AST_FUNCTION) {
    if(scopelookup(node->function.name, SYM_FUNC, scope, 1) != NULL) {
      fprintf(stderr, "ivar: '%s': redefinition.\n", node->function.name);
      exit(1);
    }
    
    scopeaddsymbol(node->function.name, node->function.type, 
                   SYM_FUNC, scope);

    struct Scope* funcscope = newscope(node, scope);
    if(!funcscope) return 1;

    semanticanalyze(node->function.body, funcscope); 

    free(funcscope);
  }
  else if(node->type == AST_IDENT) {
    if(!scopelookup(node->ident, SYM_ALL, scope, 0)) {
      fprintf(stderr, "ivar: '%s': undeclared identifier.\n", node->ident);
      exit(1);
    }
  }

  else if(node->type == AST_CALL) {
    if(!scopelookup(node->call.name, SYM_FUNC, scope, 0)) {
      fprintf(stderr, "ivar: call to undeclared function: '%s'.\n", node->ident);
      exit(1);
    }
  }

  return 0;
}

static void astprintindent(int indent) {
  for (int i = 0; i < indent; i++)
    printf("  ");
}

void astprint(struct AstNode* node, int indent) {
  if (!node) return;

  astprintindent(indent);

  switch (node->type) {

    case AST_FUNCTION:
      printf("Function: %s -> %s\n",
             node->function.name,
             node->function.type);

      astprint(node->function.body, indent + 1);
      break;

    case AST_VAR_DECL:
      printf("VarDecl: %s : %s\n",
             node->var_decl.name,
             node->var_decl.type);

      astprint(node->var_decl.val, indent + 1);
      break;

    case AST_BLOCK:
    case AST_CALL:
    case AST_PROGRAM:
      printf("Block/List: %s\n", node->type == AST_CALL ? node->call.name : (node->type == AST_FUNCTION ? node->function.name : "block/program"));
      for (size_t i = 0; i < node->list.childs_n; i++) {
        astprint(node->list.childs[i], indent + 1);
      }
      break;


    case AST_NUMBER:
      printf("Number: %lld\n", (long long)node->number);
      break;

    case AST_IDENT:
      printf("Ident: %s\n", node->ident);
      break;

    default:
      printf("Unknown AST Node\n");
      break;
  }

}
